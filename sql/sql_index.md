# SQL Index  

- 도서관에서 도서 찾기 시스템
- 도 서관에서 책을 찾을 때 고객이 원하는 책을 하나하나 찾는 것보다 도서 찾기 컴퓨터를 이용해서 어느 위치에 있는지 출력하고 찾아가는게 더 빠르다.
- 인덱스도 특정 테이블에 대한 데이터를 새롭게 정렬시켜 원하는 데이터를 빠르게 찾을 수 있게 도와주는 테이블이라고 보면된다. 
 
### 인덱스 내부 정렬 방식
 
- 이진 탐색 트리(Binary Search Tree)를 사용한다. 짧게 B-Tree, BST 라고도 한다.
- 내부적으로 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장한다.
- 이진 탐색 트리에 대한 시간 복잡도는 log n(참고)이다. 참고된 글을 보면 나와있지만 짧게 말해서 이진 탐색 트리는 업앤다운 게임을 하는 것과 비슷하다. 업앤다운 게임이 뭔지 잘 모르겠다면 클릭! 당연히 순차적으로 하나하나 찾는 것보다 업앤다운식으로 찾는게 더 효율적이다.
- 이진 탐색 트리는 이진 트리에서 정렬된 상태를 말한다. 이 말은 이미 정렬이 된 상태로 인덱스가 생성되기 때문에 INDEX를 조회할 때 전체를 정렬해서 찾는 개념이 아니라는 뜻.
- 인덱스에 해당 하는 컬럼을 기준으로 검색을 해야 인덱스를 참고하면서 접근이 빨라진다.
 
SELECT 문만 빨라지고 INSERT, UPDATE, DELETE는 느려진다.
INDEX가 걸려있는 테이블에 데이터 수정을 하게 되면 indexing이 새로 일어나 속도가 느려질 수 밖에 없다.
만약에 갱신이 너무 자주 일어나는 테이블에 인덱스를 쓰고 있다면 뭔가 잘못 쓰고 있다는 것이다.
더불어 전체 데이터의 10~15퍼센트를 조회할 때 성능이 좋으며 그 이외에는 풀스캔하는게 나을 수도 있다고 한다.
 
*인덱스의 개수가 많으면 좋지 않다.*
인덱스가 너무 많으면 옵티마이저가 인덱스를 잘못 선택할 확률이 높아진다. 3개 정도로 유지시키는 것이 좋다.
 
### LIKE 대신 FULL TEXT을 사용
문자열 검색을 위해 LIKE를 사용할 경우 인덱스가 사용되지 않는다. 이럴떈 FULL TEXT를 이용해서 처리하면 속도 향상을 시킬 수 있다. FULL TEXT는 자연언어의 검색을 처리하기 위해서 사용된다고 한다.

- 중복도가 높다 = 분포도가 낮다 = Cardinality가 낮다 = 나타나는 데이터의 종류가 별로 없다
- 중복도가 낮다 = 분포도가 높다 = Cardinality가 높다 = 나타나는 데이터의 종류가 많다
